
<html>
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Tehnici Algoritmice</title>
        <link rel="website icon" type="png" href="images/CR.png">
        <link rel="stylesheet" href="css/stylesheet.css">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/base16/chalk.min.css">
        <link rel="stylesheet" href="link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
        <script src="https://kit.fontawesome.com/64d58efce2.js" crossorigin="anonymous"></script>
    </head>
    <body>
        <header>
        <div class="hero-image" id="hero-image">
            <div class="hero-text">
                <h2>Tehnici algoritmice</h2>
        </div>
        <div id="sideNav">
            <nav>
                <ul>
                    <li><a href="#">ACASĂ</a></li>
                    <li><a href="#introducere">Metoda Trierii</a></li>
                    <li><a href="#ec-omogene_2">Metoda Greedy</a></li>
                    <li><a href="#ec-omogene_3">Recursia</a></li>
                    <li><a href="#ec-omogene_4">Backtracking</a></li>
                    <li><a href="#footer">Final</a></li>
                </ul>
            </nav>
        </div>
    </header>
        <div id="manuBtn">
            <img src="images/menu.png" alt="" id="menu">
        </div>
        <section id="introducere">
            <div class="title-text">
                <p>METODA TRIERII</p>
            </div>
            <div class="feature-box">
                <div class="features">
                    <div class="features-desc">
                        <div class="feature-icon">
                            <i class="fa-solid fa"></i>
                        </div>
                        <div class="feature-text">
                            <p>
                                Se numește metoda trierii metoda ce identifică toate soluțiile unei probleme in dependență de mulțimea soluțiilor posibile. Toate soluțiile se indentifică prin valori, ce aparțin tipurilor de date studiate: integer, boolean, enumerare sau subdomeniu. În probleme mai complicate este nevoie de a reprezenta aceste elemente prin tablouri, articole sau mulțimi.
                            </p>
                        </div>
                    </div>
                    <div class="features-desc" style="margin-bottom: initial;">
                        <div class="feature-icon">
                            <i class="fa-solid fa"></i>
                        </div>
                        <div class="feature-text">
                            <p> 
                                Avantajul principal al algoritmilor bazați pe metoda trierii constă în faptul că programele respective sunt relativ simple, iar depanarea lor nu necesită teste sofisticate. În majoritatea problemelor de o reală importanță practică metoda trierii conduce la algoritmii exponențiali.
                            </p>
                        </div>
                    </div>
                </div>
                <div class="features-img">
                    <img src="images/Sorting.jpg" alt="">
                </div>
            </div>
        </section>
        <section id="exempleI">
            <div class="title-text">
                <p>EXEMPLE</p>
            </div>
            <div class="row">
                <div class="column">
                <h2 class="title_prob">Scrieți un program care citește de la tastatură o serie de numere și le sortează tabloul în ordine crescătoare, afișând rezultatul.</h2>
                <pre>
                    <code class="language-cpp" style="background: #425664; font-size: 15px;">
                        
    #include  &ltiostream&gt
    using namespace std;

    int main() {
        int l, a[l];
        cout << "Introdu lungimea tabloului: ";
        cin >> l;
        cout << "Introdu elementele tabloului:";
        for (int i = 0; i < l; ++i) {
            cin >> a[i];
        }

        for (int i = 0; i < l - 1; i++) {
            for (int j = 0; j < l - i - 1; j++) {
                if (a[j] > a[j + 1]) {
                    int t = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = t;
                }
            }
        }

        cout << "Tabloul sortat: ";
        for (int i = 0; i < l; ++i) {
            cout << a[i] << " ";
        }

        return 0;
    }
                    </code>
                </pre>
            </div>
                <div class="column">
                <h2 class="title_prob">Realizează un program care citește de la tastatură un set de cuvinte și le sortează în ordine alfabetică folosind metoda bulelor.</h2>
                <pre>
                    <code class="language-cpp" style="background: #425664; font-size: 15px;">


        #include &ltiostream&gt
        #include &ltstring&gt
        using namespace std;
        
        int main() {
            int n; string cuvinte[mm];
            cout << "Introdu numarul de cuvinte: ";
            cin >> n;
        
            for (int i = 0; i < n; ++i) {
                cin >> cuvinte[i];
            }
        
            for (int i = 0; i < n - 1; i++) {
                for (int j = 0; j < n - i - 1; j++) {
                    if (cuvinte[j] > cuvinte[j + 1]) {
                        string temp = cuvinte[j];
                        cuvinte[j] = cuvinte[j + 1];
                        cuvinte[j + 1] = temp;
                    }
                }
            }
        
            cout << "Cuvintele sortate: ";
            for (int i = 0; i < n; ++i) {
                cout << cuvinte[i] << " ";
            }
        
            return 0;
        }
                             
                    </code>
                </pre>
            </div>
            <div class="column">
                <h2 class="title_prob">Sortează un tablou de numere întregi în ordine descrescătoare folosind metoda bulelor și apoi identifică și afișează cel mai mic și cel mai mare element din tablou.</h2>
                <pre>
                    <code class="language-cpp" style="background: #425664; font-size: 15px;">

        #include &ltiostream&gt
        using namespace std;
                
        int main() {
            int n, a[n];

            cout << "Introdu numarul de elemente: ";
            cin >> n;

            for (int i = 0; i < n; ++i) {
                cin >> a[i];
            }

            for (int i = 0; i < n - 1; i++) {
                for (int j = 0; j < n - i - 1; j++) {
                    if (a[j] < a[j + 1]) {
                        int t = a[j];
                        a[j] = a[j + 1];
                        a[j + 1] = t;
                    }
                }
            }

            cout << "Numerele sortate descrescator: ";
            for (int i = 0; i < n; ++i) {
                cout << a[i] << " ";
            }

            int celMaiMic = a[n - 1];
            int celMaiMare = a[0];

            cout << "Cel mai mic element: " 
            << celMaiMic << endl;
            cout << "Cel mai mare element: " 
            << celMaiMare << endl;

            return 0;
        }
                            
                    </code>
                </pre>
            </div>
        </div>
        </section>
        <section id="ec-omogene_2">
            <div class="title-text">
                <p>METODA GREEDY</p>
            </div>
            <div class="feature-box">
                <div class="features">
                    <div class="features-desc">
                        <div class="feature-icon">
                            <i class="fa-solid fa"></i>
                        </div>
                        <div class="feature-text">
                            <p>
                                Metoda Greedy este una dintre cele mai directe tehnici de proiectare a algoritmilor care poate fi aplicata la o gama larga de probleme. In general, aceasta meoda se aplica problemelor de optimizare. Majoritatea acestor probleme constau in determinarea unei submultimi B, a unei multimi A cu n elemente care sa indeplineasca anumite conditii pentru a fi acceptata. 
                            </p>
                        </div>
                    </div>
                    <div class="features-desc">
                        <div class="feature-icon">
                            <i class="fa-solid fa"></i>
                        </div>
                        <div class="feature-text">
                            <p> 
                                Specificul acestei metode constă în faptul că se construieste soluția optimă pas cu pas, la fiecare pas fiind selectat (sau „înghișit”) în solușie elementul care pare „cel mai bun” la momentul respectiv, în speranța că va duce la solușie optimă globală.
                            </p>
                        </div>
                    </div>                  
                </div>
            <div class="features-img">
                <img src="images/Greedy.png" alt="">
            </div>
            </div>
        </section>
            <section id="exempleI">
                <div class="title-text">
                    <p>EXEMPLE</p>
                </div>
                <div class="row">
                    <div class="column">
                    <h2 class="title_prob">Cunoscând timpul necesar pentru repararea fiecărei maşini, scrieți un program care calculează numărul maxim de maşini care pot fi reparate într-un interval de timp T.</h2>
                    <pre>
                        <code class="language-cpp" style="background: #425664; font-size: 15px;">





        #include &lt;iostream&gt;
        using namespace std;
        
        int n, t; int a[1001];
        
        void sortare (int a[n], int n)
        { bool este_sortat = false;
        while(!este_sortat){
        este_sortat = true; 
        for(int i = 1; i < n; ++i) 
        if(a[i] > a[i+1]){
        este_sortat = false;
        }
        swap(a[i], a[i+1]);
        }
        }
        
        int main(){
        cin >> n >> t;
        for(int i = 1; i <= n; ++i) 
        cin >> a[i];
        sortare (a, n);
        int i = 1;
        while(t - a[i] >= 0 && i <= n) t -= a[i], i++;
        cout << i - 1;
        return 0;
        }
                        </code>
                    </pre>
                </div>
                    <div class="column">
                    <h2 class="title_prob">Se considera ca dispunem de un rucsac cu capacitatea M si de N obiecte, definite fiecare prin greutate si valoare, ce trebuie introduce in rucsac. Se cere o modalitate de a umple rucsacul cu obiecte , astfel incat valoarea totala sa fie maxima. Este posibil ca oricate obiecte si bucati din obiecte sa fie introduse.</h2>
                    <pre>
                        <code class="language-cpp" style="background: #425664; font-size: 15px;">


            #include &lt;iostream&gt;
            using namespace std;
            
            int o[100],N,M;
            float val[100],greu[100],x[100],Gr;
            
            void  citeste()
            {
                int i;
                cin>>N>>M;
                for (i=0;i&lt;N;++i)
                {
                    o[i]=i;
                    cin>>val[i]>>greu[i];
                }
            }
            
            void sort()
            {
                int i,aux,schimb;
                while (schimb);
            {
            schimb=0;
            for (i=0;i&lt;N-1;++i)
            if (val[o[i]]/greu[o[i]]&lt;val[o[i+1]]/greu[o[i+1]])
            {
            aux=o[i];
            o[i]=o[i+1];
            o[i+1]=aux;
            schimb=1;
            }
            }	
            }
            
            void rezolva()
            {
                int i;
                for (i=0,Gr=M;i&lt;N && Gr>greu[o[i]];i++)
                {
                    x[o[i]]=1;
                    Gr-=greu[o[i]];
                }
            }
            
            void afisare()
            {
            int i;
            for (i=0;i&lt;N;i++)
            if (x[i]) 
            cout&lt;&lt;i+1<<" "&lt;&lt;x[i]*1007&lt;&lt;endl;
            }
            
            int main()
            {
                citeste();
                sort();
                rezolva();
                afisare();
                return 0;
            }
                                 
                        </code>
                    </pre>
                </div>
                <div class="column">
                    <h2 class="title_prob"> S-au propus n (n <= 100) spectacole, pentru fiecare spectacol a fost anunțat intervalul în care se poate desfășura [si,Fi] (Si reprezinta ora si minutul de inceput,iar Fi ora și minutul de final al spectacolului i), scrieți un program care să permita spectatorilor vizionarea unui număr cât mai mare de spectacole.</h2>
                    <pre>
                        <code class="language-cpp" style="background: #425664; font-size: 15px;">
                            
        #include &lt;iostream&gt;
        using namespace std;
        
        struct spectacol
        {
        int s,d;
        };
        
        void citire(int n, spectacol a[n])
        {
        cin>>n;
        for(int i=1;i<=n;i++)
        cin>>a[i].s>>a[i].d;
        }
        
        void ordonare(int n, spectacol a[n])
        {
        int i,j;
        spectacol aux;
        for(i=1;i&lt;n;i++)
        for(j=i+1;j<=n;j++)
        if(a[i].d>a[j].d)
        {
        aux=a[i]; a[i]=a[j]; a[j]=aux;
        }
        }
        
        void afisare(int n, spectacol a[])
        {
        for(int i=1;i<=n;i++)
        cout&lt;&lt;[i].s<<","&lt;&lt;a[i].d&lt;&lt;" ";
        }
        
        void greedy(int n, spectacol a[n])
        {
        spectacol s[100];
        int i,k;
        k=1;
        s[1]=a[1];
        for(i=2;i<=n;i++)
        if(s[k].d&lt;a[i].s) s[k++]=a[i];
        afisare(k,s);
        }
        
        int main()
        {
        int n;
        spectacol a[100];
        citire(n,a);
        ordonare(n,a);
        greedy(n,a);
        }
                                
                        </code>
                    </pre>
                </div>
            </div>
            </section>
            <section id="ec-omogene_3">
                <div class="title-text">
                    <p>RECURSIA</p>
                </div>
                <div class="feature-box">
                    <div class="features">
                        <div class="features-desc">
                            <div class="feature-icon">
                                <i class="fa-solid fa"></i>
                            </div>
                            <div class="feature-text">
                                <p>
                                    Recursivitatea este proprietatea unui element de a se defini prin el însuși. Recursivitatea aduce o nouă metodă de a vizualiza problemele. Această metodă, de a împărți problema curentă în probleme mai mici, până când ajungem la probleme simple și rezolvabile instant, va fi mai târziu folosită la programarea dinamică.
                                </p>
                            </div>
                        </div>
                        <div class="features-desc">
                            <div class="feature-icon">
                                <i class="fa-solid fa"></i>
                            </div>
                            <div class="feature-text">
                                <p> 
                                    Soluțiile recursive, fără optimizări, pot lua mai mult timp să ruleze, astfel că implementările recursive nu sunt foarte utile în programe în care viteza este importantă. Cu toate acestea, de obicei acest lucru nu reprezintă un pericol.
                                </p>
                            </div>
                        </div>                  
                    </div>
                <div class="features-img">
                    <img src="images/recursia.png" alt="">
                </div>
                </div>
            </section>
                <section id="exempleI">
                    <div class="title-text">
                        <p>EXEMPLE</p>
                    </div>
                    <div class="row">
                        <div class="column">
                        <h2 class="title_prob">Să se creeze o funcție care primește un număr n și returnează al n-lea număr Fibonacci.</h2>
                        <pre>
                            <code class="language-cpp" style="background: #425664; font-size: 15px;">
        #include &lt;iostream&gt;
        using namespace std;
        int f(int n) 
        {
        if (n <= 1)
        return n;
        int a = 0, b = 1, c=0;
        for (int i = 2; i <= n; i++)
        {
        c = a + b;
        a = b;
        b = c;
        }
        return c;
        }
        
        int main()
        {
        int n;
        cin>>n;
        int c = f(n);
        cout << "Al " << n << "-lea numar
        Fibonacci este " << c &lt;&lt;endl;
        return 0;
        }
                            </code>
                        </pre>
                    </div>
                        <div class="column">
                        <h2 class="title_prob">Avem intervalul [n, m] de selectat numerele pentru care oglinditul este prim.</h2>
                        <pre>
                            <code class="language-cpp" style="background: #425664; font-size: 15px;">
    
            #include &lt;iostream&gt;
            using namespace std;
            int f(int x) 
            {
            int y = 0;
            while (x > 0)
            {
            y = y * 10 + x % 10;
            x = x / 10;
            }
            return y;
            }
            bool p(int x) 
            {
            int i = 2;
            
            bool b = true;
            while (b && i <= x / 2)
            if (x % i == 0)
            b = false;
            else
            i++;
            return b;
            }
            int main()
            {
            int n, m, i;
            cin >> n >> m;
            for (i = n; i <= m; i++)
            if (p(f(i)))
            cout << i << " ";
            
            return 0;}
                                     
                            </code>
                        </pre>
                    </div>
                    <div class="column">
                        <h2 class="title_prob"> Să se creeze o funcție care primește un număr întreg și returnează factorialul acestuia.</h2>
                        <pre>
                            <code class="language-cpp" style="background: #425664; font-size: 15px;">               
        #include &lt;iostream&gt;
        using namespace std;
        int f(int n)
        {
        if (n == 0)
        return 1;
        return n * f(n - 1);
        }
        
        int main()
        {
        int n, r;
        cin >> n;
        r = f(n);
        cout << n << "! = " << r << endl;
        return 0;}
                                    
                            </code>
                        </pre>
                    </div>
                </div>
                </section>
                <section id="ec-omogene_4">
                    <div class="title-text">
                        <p>BACKTRACKING</p>
                    </div>
                    <div class="feature-box">
                        <div class="features">
                            <div class="features-desc">
                                <div class="feature-icon">
                                    <i class="fa-solid fa"></i>
                                </div>
                                <div class="feature-text">
                                    <p>
                                        Metoda backtracking se aplică algoritmilor pentru rezolvarea următoarelor tipuri de probleme: Fiind date n mulţimi S1, S2, ... Sn, fiecare având un număr nrsi de elemente, se cere găsirea  elementelor vectorului X =(x1, x2, ... xn) ϵ S=S1xS2x…Sn, astfel încât să fie îndeplinită o anumită  relaţie φ(x1, x2, … ,xn) între elementele sale.
                                    </p>
                                </div>
                            </div>
                            <div class="features-desc">
                                <div class="feature-icon">
                                    <i class="fa-solid fa"></i>
                                </div>
                                <div class="feature-text">
                                    <p> 
                                        Metoda backtracking determină toate soluţiile rezultat ale problemei. Dintre acestea se  poate alege una care îndeplineşte în plus o altă condiţie.
                                    </p>
                                </div>
                            </div>                  
                        </div>
                    <div class="features-img">
                        <img src="images/back.png" alt="">
                    </div>
                    </div>
                </section>
                    <section id="exempleI">
                        <div class="title-text">
                            <p>EXEMPLE</p>
                        </div>
                        <div class="row">
                            <div class="column">
                            <h2 class="title_prob">Să se creeze o funcție care primește un număr n și returnează al n-lea număr Fibonacci.</h2>
                            <pre>
                                <code class="language-cpp" style="background: #425664; font-size: 15px;">





            #include &lt;iostream&gt;
            using namespace std;
            int n, k, st[1000];
            void tipar(int p)
            
            {
            int i;
            for (i = 1; i <= p; i++)
            cout << st[i] << " ";
            cout << endl;
            }
            int nr(int p)
            
            {
            int s = 0, i;
            
            for (i = 1; i <= p; i++)
            s = s + st[i];
            return s;}
            bool f(int p)
            
            {
            return nr(p) <= k;
            }
            void bktr(int p)
            
            {
            int j;
            for (j = 0; j <= 1; j++)
            {
            st[p] = j;
            if (f(p))
            
            if (p == n)
            {
            if (nr(n) == k)
            tipar(n);
            else bktr(p + 1);
            }}}
            int main()
            {
            cin >> n >> k;
            bktr(1);
            return 0;
            }
                                </code>
                            </pre>
                        </div>
                            <div class="column">
                            <h2 class="title_prob">Se consideră n mulţimi finite S1, S2, ... Sn, de forma {1,2..,sn}. Să se genereze produsul cartezian  al acestor mulţimi</h2>
                            <pre>
                                <code class="language-cpp" style="background: #425664; font-size: 15px;">
        



                                    
        #include &lt;iostream&gt;
        using namespace std;
        
        int x[50], n,k,s[50][100], card[50];
        
        void citeste()
        { int i,j; f>>n;
            for(i=1;i<=n;i++)
            { cin>>card[i];
            for(j=1;j<=card[i];j++) 
            cin>>s[i][j];}
            }
        
        void scrie()
        { int i;
            cout&lt;&lt;endl;
            for(i=1;i<=n;i++) 
            cout&lt;&lt;s[i][x[i]]<<" ";}
        int solutie(int k) 
        { return(k==n+1);}
        
        void back(int k)
        { if(solutie(k))scrie();
            else for(int i=1;i<=card[k];i++)
            {x[k]=i;
            back(k+1);}
        }
        
        int main()
        {citeste(); 
        back(1); 
        return 0;}
                                        
                                         
                                </code>
                            </pre>
                        </div>
                        <div class="column">
                            <h2 class="title_prob"> Se consideră multimea {1,2,…,n}. Se cer toate partițiile acestei mulțimi. Submulțimile A1,A2,…,Ak ale mulțimii A constituie o partiție a acesteia dacă sunt disjuncte între ele (nu au elemente comune)  și mulțimea rezultată în urma reuniunii lor este A.
                                </h2>
                            <pre>
                                <code class="language-cpp" style="background: #425664; font-size: 15px;">        #include &lt;iostream&gt;
        using namespace std;
        int x[50],a[50], n, nrsol;
        void citeste()
        {ifstream f("fis.in");
        f>>n;
        int i;
        for(i=1;i<=n;i++)f>>a[i];
        }
        int maxim(int k)
        {int i,z=0;
            for(i=1;i&lt;k;i++)
            z=max(x[i],z);
            return z;
        }
        void scrie()
        { int i,z,j;
            nrsol++;
            cout&lt;&lt;endl&lt;&lt;"Solutia "&lt;&lt;nrsol&lt;&lt;endl;
            cout&lt;&lt;endl;
            z=maxim(n+1);
            for(i=1;i<=z;i++)
            {cout<<"{ ";
            for(j=1;j<=n;j++)
            if(x[j]==i)cout&lt;&lt;a[j]<<" ";
            cout<<"} ";
        }}
        void back(int k)
        { if(k==n+1)scrie();
            else
            for(int i=1; i<=maxim(k)+1;i++)
            { x[k]=i;
            back(k+1);}
        }
        int main()
        { citeste();
        x[1]=1;
        back(2);
        return 0;}
                                        
                                        
                                </code>
                            </pre>
                        </div>
                    </div>
                    </section>
        <section id="footer">
            <div class="title-text">
                <p>CONTACT</p>
            </div>
            <div class="footer-row">
                <div class="footer-left">
                    <h1>Realizat de:</h1>
                    <i class="fa fa-solid fa-arrow-right"></i>Străjescu Ovidiu</p>
                </div>
                <div class="footer-center">
                    <img src="images/dante.png" alt="">
                </div>
                <div class="footer-right">
                    Aceste patru concepte – backtracking, recursie, metoda greedy și triere – reprezintă abordări fundamentale în rezolvarea problemelor algoritmice în informatică. Backtracking implică explorarea recursivă a tuturor soluțiilor posibile, revenind atunci când o soluție este invalidă. Recursia, prin apelul unei funcții către ea însăși, abordează probleme divizibile în subprobleme mai mici. Metoda Greedy adoptă decizii locale optime în fiecare pas, fiind utilizată în optimizarea funcțiilor. Trierile, procesul de ordonare a elementelor, sunt esențiale în diverse aplicații, de la căutare eficientă la statistici și algoritmi. Toate aceste tehnici sunt instrumente de bază în dezvoltarea algoritmilor și rezolvarea eficientă a problemelor în domeniul informaticii.
                </div>
            </div>
            <div class="social-links">
                <p>Copyright &copy; 2023 - S.O.</p>
            </div>
        </section>
        <script src="js/script.js"></script>
        <script type="text/javascript">
            window.addEventListener("scroll", function() {
              var header = document.querySelector("header");
              header.classList.toggle("sticky", window.scrollY > 0);
            });     
        </script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script>
    </body>
</html>